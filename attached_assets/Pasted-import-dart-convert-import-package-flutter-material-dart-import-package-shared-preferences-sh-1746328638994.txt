import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:daoob_mobile/services/auth_service.dart';
import 'package:daoob_mobile/models/booking.dart';
import 'package:sqflite/sqflite.dart';
import 'package:path/path.dart';
import 'package:http/http.dart' as http;

class BookingService extends ChangeNotifier {
  List<Booking> _bookings = [];
  bool _isLoading = false;
  String? _error;
  late Database _database;
  bool _isInitialized = false;
  
  List<Booking> get bookings => _bookings;
  bool get isLoading => _isLoading;
  String? get error => _error;

  // Initialize database
  Future<void> initialize() async {
    if (_isInitialized) return;
    
    try {
      final databasePath = await getDatabasePath();
      _database = await openDatabase(
        databasePath,
        version: 1,
        onCreate: (db, version) async {
          await db.execute(
            '''
            CREATE TABLE bookings(
              id INTEGER PRIMARY KEY,
              clientId INTEGER,
              vendorId INTEGER,
              status TEXT,
              bookingDate TEXT,
              eventDate TEXT,
              packageType TEXT,
              totalPrice REAL,
              notes TEXT,
              createdAt TEXT,
              vendorName TEXT,
              clientName TEXT
            )
            ''',
          );
        },
      );
      _isInitialized = true;
    } catch (e) {
      _error = 'Failed to initialize database: $e';
      notifyListeners();
    }
  }

  Future<String> getDatabasePath() async {
    return join(await getDatabasesPath(), 'daoob_bookings.db');
  }

  // Load bookings from database or API
  Future<void> loadBookings(AuthService authService, {bool forceRefresh = false}) async {
    if (!_isInitialized) await initialize();
    
    try {
      _isLoading = true;
      _error = null;
      notifyListeners();

      if (authService.isOfflineMode || !forceRefresh) {
        // Try to load from local database first
        await _loadBookingsFromDatabase(authService.user!.id, authService.user!.userType);
      }

      // If online and we need fresh data, fetch from API
      if (!authService.isOfflineMode && (forceRefresh || _bookings.isEmpty)) {
        await _fetchBookingsFromApi(authService.user!.id, authService.user!.userType);
      }

      // If still empty and offline, generate mock data
      if (_bookings.isEmpty && authService.isOfflineMode) {
        _generateMockBookings(authService.user!.id, authService.user!.userType);
      }

      _isLoading = false;
      notifyListeners();
    } catch (e) {
      _isLoading = false;
      _error = e.toString();
      notifyListeners();
    }
  }

  // Load bookings from the local database
  Future<void> _loadBookingsFromDatabase(int userId, String userType) async {
    final String fieldName = userType == 'vendor' ? 'vendorId' : 'clientId';
    final List<Map<String, dynamic>> maps = await _database.query(
      'bookings',
      where: '$fieldName = ?',
      whereArgs: [userId],
    );
    
    _bookings = List.generate(maps.length, (i) {
      return Booking.fromJson(maps[i]);
    });
  }

  // Fetch bookings from the API
  Future<void> _fetchBookingsFromApi(int userId, String userType) async {
    try {
      final endpoint = userType == 'vendor' 
        ? 'https://api.daoob.com/bookings/vendor/$userId'
        : 'https://api.daoob.com/bookings/client/$userId';
        
      final response = await http.get(Uri.parse(endpoint));
      
      if (response.statusCode == 200) {
        final List<dynamic> bookingsJson = json.decode(response.body);
        _bookings = bookingsJson.map((json) => Booking.fromJson(json)).toList();
        
        // Cache bookings in the database
        await _cacheBookingsInDatabase(_bookings);
      } else {
        throw Exception('Failed to load bookings');
      }
    } catch (e) {
      throw Exception('Error fetching bookings: $e');
    }
  }

  // Cache bookings in the local database
  Future<void> _cacheBookingsInDatabase(List<Booking> bookings) async {
    final batch = _database.batch();
    
    // Clear existing bookings
    batch.delete('bookings');
    
    // Insert new bookings
    for (var booking in bookings) {
      batch.insert('bookings', booking.toJson());
    }
    
    await batch.commit(noResult: true);
  }

  // Generate mock bookings for offline testing
  void _generateMockBookings(int userId, String userType) {
    _bookings = Booking.getMockBookings(
      isVendor: userType == 'vendor',
      userId: userId,
    );
    
    // Cache mock bookings
    _cacheBookingsInDatabase(_bookings);
  }

  // Create a new booking
  Future<Booking?> createBooking(AuthService authService, Booking booking) async {
    if (!_isInitialized) await initialize();
    
    try {
      _isLoading = true;
      _error = null;
      notifyListeners();

      Booking createdBooking;
      
      if (!authService.isOfflineMode) {
        // Online mode - create booking through API
        final response = await http.post(
          Uri.parse('https://api.daoob.com/bookings'),
          headers: {'Content-Type': 'application/json'},
          body: json.encode(booking.toJson()),
        );
        
        if (response.statusCode == 201) {
          createdBooking = Booking.fromJson(json.decode(response.body));
        } else {
          throw Exception('Failed to create booking');
        }
      } else {
        // Offline mode - create booking locally with mock data
        final now = DateTime.now();
        createdBooking = Booking(
          id: now.millisecondsSinceEpoch, // Generate unique ID
          clientId: booking.clientId,
          vendorId: booking.vendorId,
          status: 'pending',
          bookingDate: now,
          eventDate: booking.eventDate,
          packageType: booking.packageType,
          totalPrice: booking.totalPrice,
          notes: booking.notes,
          createdAt: now,
          vendorName: booking.vendorName,
          clientName: booking.clientName,
        );
      }
      
      // Add to local list and cache
      _bookings.add(createdBooking);
      await _database.insert('bookings', createdBooking.toJson());
      
      _isLoading = false;
      notifyListeners();
      return createdBooking;
    } catch (e) {
      _isLoading = false;
      _error = e.toString();
      notifyListeners();
      return null;
    }
  }

  // Update booking status
  Future<bool> updateBookingStatus(AuthService authService, int bookingId, String newStatus) async {
    if (!_isInitialized) await initialize();
    
    try {
      _isLoading = true;
      _error = null;
      notifyListeners();

      if (!authService.isOfflineMode) {
        // Online mode - update through API
        final response = await http.patch(
          Uri.parse('https://api.daoob.com/bookings/$bookingId'),
          headers: {'Content-Type': 'application/json'},
          body: json.encode({'status': newStatus}),
        );
        
        if (response.statusCode != 200) {
          throw Exception('Failed to update booking status');
        }
      } 
      
      // Update in local list and database
      final index = _bookings.indexWhere((booking) => booking.id == bookingId);
      if (index != -1) {
        final updatedBooking = Booking(
          id: _bookings[index].id,
          clientId: _bookings[index].clientId,
          vendorId: _bookings[index].vendorId,
          status: newStatus,
          bookingDate: _bookings[index].bookingDate,
          eventDate: _bookings[index].eventDate,
          packageType: _bookings[index].packageType,
          totalPrice: _bookings[index].totalPrice,
          notes: _bookings[index].notes,
          createdAt: _bookings[index].createdAt,
          vendorName: _bookings[index].vendorName,
          clientName: _bookings[index].clientName,
        );
        
        _bookings[index] = updatedBooking;
        
        await _database.update(
          'bookings',
          {'status': newStatus},
          where: 'id = ?',
          whereArgs: [bookingId],
        );
      }
      
      _isLoading = false;
      notifyListeners();
      return true;
    } catch (e) {
      _isLoading = false;
      _error = e.toString();
      notifyListeners();
      return false;
    }
  }
}
